{"version":3,"sources":["CandyMachine/index.js","CountdownTimer/index.js","assets/twitter-logo.svg","App.js","index.js","CandyMachine/helpers.js"],"names":["programs","metadata","Metadata","MetadataProgram","config","web3","PublicKey","process","SystemProgram","opts","CandyMachine","walletAddress","useState","machineStats","setMachineStats","mints","setMints","isMinting","setIsMinting","isLoadingMints","setIsLoadingMints","fetchHashTable","hash","metadataEnabled","a","connection","Connection","console","log","getProgramAccounts","filters","memcmp","offset","bytes","metadataAccounts","mintHashes","index","length","account","getParsedAccountInfo","pubkey","accountInfo","toString","value","push","data","mint","getMetadata","findProgramAddress","Buffer","from","TOKEN_METADATA_PROGRAM_ID","toBuffer","getMasterEdition","getTokenWallet","wallet","TOKEN_PROGRAM_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","mintToken","Keypair","generate","publicKey","token","masterEdition","getMinimumBalanceForRentExemption","MintLayout","span","rent","accounts","candyMachine","payer","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","programId","SYSVAR_RENT_PUBKEY","clock","SYSVAR_CLOCK_PUBKEY","signers","instructions","createAccount","fromPubkey","newAccountPubkey","space","lamports","Token","createInitMintInstruction","createAssociatedTokenAccountInstruction","createMintToInstruction","provider","getProvider","Program","fetchIdl","candyMachineProgram","idl","program","rpc","mintNft","txn","onSignatureWithOptions","notification","context","type","result","err","getCandyMachineState","commitment","message","msg","code","indexOf","warn","associatedTokenAddress","splTokenMintAddress","keys","isSigner","isWritable","TransactionInstruction","Provider","window","solana","fetch","itemsAvailable","toNumber","itemsRedeemed","itemsRemaining","goLiveData","goLiveDate","goLiveDateTimeString","Date","toGMTString","requests","map","uri","response","json","parse","image","error","Promise","all","allMints","filteredMints","filter","useEffect","className","currentDate","dropDate","renderDropTimer","onClick","disabled","src","alt","CountdownTimer","timerString","setTimerString","interval","setInterval","getTime","distance","days","Math","floor","hours","minutes","seconds","clearInterval","TWITTER_HANDLE","TWITTER_LINK","App","setWalletAddress","checkIfWalletIsConnected","isPhantom","connect","onlyIfTrusted","alert","connectWallet","onLoad","addEventListener","removeEventListener","twitterLogo","href","target","rel","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ae7bb57f.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\r\nimport { Connection, PublicKey } from \"@solana/web3.js\";\r\nimport { Program, Provider, web3 } from \"@project-serum/anchor\";\r\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\r\nimport { programs } from \"@metaplex/js\";\r\nimport \"./CandyMachine.css\";\r\nimport CountdownTimer from \"../CountdownTimer\";\r\nimport {\r\n  candyMachineProgram,\r\n  TOKEN_METADATA_PROGRAM_ID,\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n} from \"./helpers\";\r\n\r\n//const { Metadata, MetadataProgram } = programs;\r\nconst {\r\n  metadata: { Metadata, MetadataProgram },\r\n} = programs;\r\n\r\nconst config = new web3.PublicKey(process.env.REACT_APP_CANDY_MACHINE_CONFIG);\r\nconst { SystemProgram } = web3;\r\nconst opts = {\r\n  preflightCommitment: \"processed\",\r\n};\r\n\r\nconst MAX_NAME_LENGTH = 32;\r\nconst MAX_URI_LENGTH = 200;\r\nconst MAX_SYMBOL_LENGTH = 10;\r\nconst MAX_CREATOR_LEN = 32 + 1 + 1;\r\n\r\nconst CandyMachine = ({ walletAddress }) => {\r\n  const [machineStats, setMachineStats] = useState(null);\r\n  const [mints, setMints] = useState([]);\r\n  const [isMinting, setIsMinting] = useState(false);\r\n  const [isLoadingMints, setIsLoadingMints] = useState(false);\r\n  // Actions\r\n  const fetchHashTable = async (hash, metadataEnabled) => {\r\n    const connection = new web3.Connection(\r\n      process.env.REACT_APP_SOLANA_RPC_HOST\r\n    );\r\n    console.log(\"MetadataProgram\", MetadataProgram);\r\n    if (!MetadataProgram) return;\r\n    const metadataAccounts = await MetadataProgram.getProgramAccounts(\r\n      connection,\r\n      {\r\n        filters: [\r\n          {\r\n            memcmp: {\r\n              offset:\r\n                1 +\r\n                32 +\r\n                32 +\r\n                4 +\r\n                MAX_NAME_LENGTH +\r\n                4 +\r\n                MAX_URI_LENGTH +\r\n                4 +\r\n                MAX_SYMBOL_LENGTH +\r\n                2 +\r\n                1 +\r\n                4 +\r\n                0 * MAX_CREATOR_LEN,\r\n              bytes: hash,\r\n            },\r\n          },\r\n        ],\r\n      }\r\n    );\r\n\r\n    const mintHashes = [];\r\n\r\n    for (let index = 0; index < metadataAccounts.length; index++) {\r\n      const account = metadataAccounts[index];\r\n      const accountInfo = await connection.getParsedAccountInfo(account.pubkey);\r\n      const metadata = new Metadata(hash.toString(), accountInfo.value);\r\n      if (metadataEnabled) mintHashes.push(metadata.data);\r\n      else mintHashes.push(metadata.data.mint);\r\n    }\r\n\r\n    return mintHashes;\r\n  };\r\n\r\n  const getMetadata = async (mint) => {\r\n    return (\r\n      await PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from(\"metadata\"),\r\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n          mint.toBuffer(),\r\n        ],\r\n        TOKEN_METADATA_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const getMasterEdition = async (mint) => {\r\n    return (\r\n      await PublicKey.findProgramAddress(\r\n        [\r\n          Buffer.from(\"metadata\"),\r\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\r\n          mint.toBuffer(),\r\n          Buffer.from(\"edition\"),\r\n        ],\r\n        TOKEN_METADATA_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const getTokenWallet = async (wallet, mint) => {\r\n    return (\r\n      await web3.PublicKey.findProgramAddress(\r\n        [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\r\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\r\n      )\r\n    )[0];\r\n  };\r\n\r\n  const mintToken = async () => {\r\n    try {\r\n      setIsMinting(true);\r\n      const mint = web3.Keypair.generate();\r\n      const token = await getTokenWallet(\r\n        walletAddress.publicKey,\r\n        mint.publicKey\r\n      );\r\n      const metadata = await getMetadata(mint.publicKey);\r\n      const masterEdition = await getMasterEdition(mint.publicKey);\r\n      const rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\r\n      const connection = new Connection(rpcHost);\r\n      const rent = await connection.getMinimumBalanceForRentExemption(\r\n        MintLayout.span\r\n      );\r\n\r\n      const accounts = {\r\n        config,\r\n        candyMachine: process.env.REACT_APP_CANDY_MACHINE_ID,\r\n        payer: walletAddress.publicKey,\r\n        wallet: process.env.REACT_APP_TREASURY_ADDRESS,\r\n        mint: mint.publicKey,\r\n        metadata,\r\n        masterEdition,\r\n        mintAuthority: walletAddress.publicKey,\r\n        updateAuthority: walletAddress.publicKey,\r\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\r\n        tokenProgram: TOKEN_PROGRAM_ID,\r\n        systemProgram: SystemProgram.programId,\r\n        rent: web3.SYSVAR_RENT_PUBKEY,\r\n        clock: web3.SYSVAR_CLOCK_PUBKEY,\r\n      };\r\n\r\n      const signers = [mint];\r\n      const instructions = [\r\n        web3.SystemProgram.createAccount({\r\n          fromPubkey: walletAddress.publicKey,\r\n          newAccountPubkey: mint.publicKey,\r\n          space: MintLayout.span,\r\n          lamports: rent,\r\n          programId: TOKEN_PROGRAM_ID,\r\n        }),\r\n        Token.createInitMintInstruction(\r\n          TOKEN_PROGRAM_ID,\r\n          mint.publicKey,\r\n          0,\r\n          walletAddress.publicKey,\r\n          walletAddress.publicKey\r\n        ),\r\n        createAssociatedTokenAccountInstruction(\r\n          token,\r\n          walletAddress.publicKey,\r\n          walletAddress.publicKey,\r\n          mint.publicKey\r\n        ),\r\n        Token.createMintToInstruction(\r\n          TOKEN_PROGRAM_ID,\r\n          mint.publicKey,\r\n          token,\r\n          walletAddress.publicKey,\r\n          [],\r\n          1\r\n        ),\r\n      ];\r\n\r\n      const provider = getProvider();\r\n      const idl = await Program.fetchIdl(candyMachineProgram, provider);\r\n      const program = new Program(idl, candyMachineProgram, provider);\r\n\r\n      const txn = await program.rpc.mintNft({\r\n        accounts,\r\n        signers,\r\n        instructions,\r\n      });\r\n\r\n      console.log(\"txn:\", txn);\r\n\r\n      // Setup listener\r\n      connection.onSignatureWithOptions(\r\n        txn,\r\n        async (notification, context) => {\r\n          if (notification.type === \"status\") {\r\n            console.log(\"Receievd status event\");\r\n\r\n            const { result } = notification;\r\n            if (!result.err) {\r\n              console.log(\"NFT Minted!\");\r\n              setIsMinting(false);\r\n              await getCandyMachineState();\r\n            }\r\n          }\r\n        },\r\n        { commitment: \"processed\" }\r\n      );\r\n    } catch (error) {\r\n      let message = error.msg || \"Minting failed! Please try again!\";\r\n      setIsMinting(false);\r\n      if (!error.msg) {\r\n        if (error.message.indexOf(\"0x138\")) {\r\n        } else if (error.message.indexOf(\"0x137\")) {\r\n          message = `SOLD OUT!`;\r\n        } else if (error.message.indexOf(\"0x135\")) {\r\n          message = `Insufficient funds to mint. Please fund your wallet.`;\r\n        }\r\n      } else {\r\n        if (error.code === 311) {\r\n          message = `SOLD OUT!`;\r\n        } else if (error.code === 312) {\r\n          message = `Minting period hasn't started yet.`;\r\n        }\r\n      }\r\n\r\n      console.warn(message);\r\n    }\r\n  };\r\n\r\n  const createAssociatedTokenAccountInstruction = (\r\n    associatedTokenAddress,\r\n    payer,\r\n    walletAddress,\r\n    splTokenMintAddress\r\n  ) => {\r\n    const keys = [\r\n      { pubkey: payer, isSigner: true, isWritable: true },\r\n      { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\r\n      { pubkey: walletAddress, isSigner: false, isWritable: false },\r\n      { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\r\n      {\r\n        pubkey: web3.SystemProgram.programId,\r\n        isSigner: false,\r\n        isWritable: false,\r\n      },\r\n      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\r\n      {\r\n        pubkey: web3.SYSVAR_RENT_PUBKEY,\r\n        isSigner: false,\r\n        isWritable: false,\r\n      },\r\n    ];\r\n    return new web3.TransactionInstruction({\r\n      keys,\r\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n      data: Buffer.from([]),\r\n    });\r\n  };\r\n\r\n  const getProvider = () => {\r\n    const rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\r\n    // Create a new connection object\r\n    const connection = new Connection(rpcHost);\r\n\r\n    // Create a new Solana provider object\r\n    const provider = new Provider(\r\n      connection,\r\n      window.solana,\r\n      opts.preflightCommitment\r\n    );\r\n\r\n    return provider;\r\n  };\r\n\r\n  // Declare getCandyMachineState as an async method\r\n  const getCandyMachineState = async () => {\r\n    const provider = getProvider();\r\n\r\n    // Get metadata about your deployed candy machine program\r\n    const idl = await Program.fetchIdl(candyMachineProgram, provider);\r\n\r\n    // Create a program that you can call\r\n    const program = new Program(idl, candyMachineProgram, provider);\r\n\r\n    // Fetch the metadata from your candy machine\r\n    const candyMachine = await program.account.candyMachine.fetch(\r\n      process.env.REACT_APP_CANDY_MACHINE_ID\r\n    );\r\n\r\n    // Parse out all our metadata and log it out\r\n    const itemsAvailable = candyMachine.data.itemsAvailable.toNumber();\r\n    const itemsRedeemed = candyMachine.itemsRedeemed.toNumber();\r\n    const itemsRemaining = itemsAvailable - itemsRedeemed;\r\n    const goLiveData = candyMachine.data.goLiveDate.toNumber();\r\n\r\n    // We will be using this later in our UI so let's generate this now\r\n    const goLiveDateTimeString = `${new Date(goLiveData * 1000).toGMTString()}`;\r\n    setMachineStats({\r\n      itemsAvailable,\r\n      itemsRedeemed,\r\n      itemsRemaining,\r\n      goLiveData,\r\n      goLiveDateTimeString,\r\n    });\r\n    console.log({\r\n      itemsAvailable,\r\n      itemsRedeemed,\r\n      itemsRemaining,\r\n      goLiveData,\r\n      goLiveDateTimeString,\r\n    });\r\n    setIsLoadingMints(true);\r\n    const data = await fetchHashTable(\r\n      process.env.REACT_APP_CANDY_MACHINE_ID,\r\n      true\r\n    );\r\n\r\n    if (data && data.length !== 0) {\r\n      const requests = data.map(async (mint) => {\r\n        // Get URI\r\n        try {\r\n          const response = await fetch(mint.data.uri);\r\n          const parse = await response.json();\r\n          console.log(\"Past Minted NFT\", mint);\r\n\r\n          // Get image URI\r\n          return parse.image;\r\n        } catch (e) {\r\n          // If any request fails, we'll just disregard it and carry on\r\n          console.error(\"Failed retrieving Minted NFT\", mint);\r\n          return null;\r\n        }\r\n      });\r\n\r\n      // Wait for all requests to finish\r\n      const allMints = await Promise.all(requests);\r\n\r\n      // Filter requests that failed\r\n      const filteredMints = allMints.filter((mint) => mint !== null);\r\n\r\n      // Store all the minted image URIs\r\n      setMints(filteredMints);\r\n      setIsLoadingMints(false);\r\n    }\r\n  };\r\n\r\n  const renderMintedItems = () => (\r\n    <div className=\"gif-container\">\r\n      <p className=\"sub-text\">Minted Items ✨</p>\r\n      <div className=\"gif-grid\">\r\n        {mints.map((mint) => (\r\n          <div className=\"gif-item\" key={mint}>\r\n            <img src={mint} alt={`Minted NFT ${mint}`} />\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n\r\n  const renderDropTimer = () => {\r\n    // Get the current date and dropDate in a JavaScript Date object\r\n    const currentDate = new Date();\r\n    const dropDate = new Date(machineStats.goLiveData * 1000);\r\n\r\n    // If currentDate is before dropDate, render our Countdown component\r\n    if (currentDate < dropDate) {\r\n      console.log(\"Before drop date!\");\r\n      // Don't forget to pass over your dropDate!\r\n      return <CountdownTimer dropDate={dropDate} />;\r\n    }\r\n\r\n    // Else let's just return the current drop date\r\n    return <p>{`Drop Date: ${machineStats.goLiveDateTimeString}`}</p>;\r\n  };\r\n\r\n  useEffect(() => {\r\n    getCandyMachineState();\r\n  }, []);\r\n\r\n  return (\r\n    machineStats && (\r\n      <div className=\"machine-container\">\r\n        {renderDropTimer()}\r\n        <p>{`Items Minted: ${machineStats.itemsRedeemed} / ${machineStats.itemsAvailable}`}</p>\r\n        {/* Check to see if these properties are equal! */}\r\n        {machineStats.itemsRedeemed === machineStats.itemsAvailable ? (\r\n          <p className=\"sub-text\">Sold Out 🙊</p>\r\n        ) : (\r\n          <button\r\n            className=\"cta-button mint-button\"\r\n            onClick={mintToken}\r\n            disabled={isMinting}\r\n          >\r\n            {isMinting ? \"Minting NFT...\" : \"Mint NFT\"}\r\n          </button>\r\n        )}\r\n        {mints.length > 0 && renderMintedItems()}\r\n        {isLoadingMints && <p>LOADING MINTS...</p>}\r\n      </div>\r\n    )\r\n  );\r\n};\r\n\r\nexport default CandyMachine;\r\n","import React, { useEffect, useState } from \"react\";\r\nimport \"./CountdownTimer.css\";\r\n\r\nconst CountdownTimer = ({ dropDate }) => {\r\n  // State\r\n  const [timerString, setTimerString] = useState(\"\");\r\n\r\n  useEffect(() => {\r\n    console.log(\"Setting interval...\");\r\n\r\n    // Use setInterval to run this piece of code every second\r\n    const interval = setInterval(() => {\r\n      const currentDate = new Date().getTime();\r\n      const distance = dropDate - currentDate;\r\n\r\n      // Here it's as easy as doing some time math to get the different properties\r\n      const days = Math.floor(distance / (1000 * 60 * 60 * 24));\r\n      const hours = Math.floor(\r\n        (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)\r\n      );\r\n      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));\r\n      const seconds = Math.floor((distance % (1000 * 60)) / 1000);\r\n\r\n      // We have our desired output, set it in state!\r\n      setTimerString(`${days}d ${hours}h ${minutes}m ${seconds}s`);\r\n\r\n      // If our distance passes zero this means that it's drop time!\r\n      if (distance < 0) {\r\n        console.log(\"Clearing interval...\");\r\n        clearInterval(interval);\r\n      }\r\n    }, 1000);\r\n\r\n    // Anytime our component unmounts let's clean up our interval\r\n    return () => {\r\n      if (interval) {\r\n        clearInterval(interval);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"timer-container\">\r\n      <p className=\"timer-header\">Candy Drop Starting In</p>\r\n      {timerString && <p className=\"timer-value\">{`⏰ ${timerString}`}</p>}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CountdownTimer;\r\n","export default __webpack_public_path__ + \"static/media/twitter-logo.4844b78f.svg\";","import React, { useEffect, useState } from \"react\";\r\nimport \"./App.css\";\r\nimport twitterLogo from \"./assets/twitter-logo.svg\";\r\nimport CandyMachine from \"./CandyMachine\";\r\n\r\n// Constants\r\nconst TWITTER_HANDLE = \"_buildspace\";\r\nconst TWITTER_LINK = `https://twitter.com/${TWITTER_HANDLE}`;\r\n\r\nconst App = () => {\r\n  const [walletAddress, setWalletAddress] = useState(null);\r\n\r\n  const checkIfWalletIsConnected = async () => {\r\n    try {\r\n      const { solana } = window;\r\n\r\n      if (solana) {\r\n        if (solana.isPhantom) {\r\n          const response = await solana.connect({ onlyIfTrusted: true });\r\n          console.log(\r\n            \"Connected with Public Key:\",\r\n            response.publicKey.toString()\r\n          );\r\n          setWalletAddress(response.publicKey.toString());\r\n        }\r\n      } else {\r\n        alert(\"Solana object not found! Get a Phantom Wallet 👻\");\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  };\r\n\r\n  const connectWallet = async () => {\r\n    const { solana } = window;\r\n\r\n    if (solana) {\r\n      const response = await solana.connect();\r\n      console.log(\"Connected with Public Key:\", response.publicKey.toString());\r\n      setWalletAddress(response.publicKey.toString());\r\n    }\r\n  };\r\n\r\n  const renderNotConnectedContainer = () => (\r\n    <button\r\n      className=\"cta-button connect-wallet-button\"\r\n      onClick={connectWallet}\r\n    >\r\n      Connect to Wallet\r\n    </button>\r\n  );\r\n\r\n  useEffect(() => {\r\n    const onLoad = async () => {\r\n      await checkIfWalletIsConnected();\r\n    };\r\n    window.addEventListener(\"load\", onLoad);\r\n    return () => window.removeEventListener(\"load\", onLoad);\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"container\">\r\n        <div className=\"header-container\">\r\n          <p className=\"header\">🍭 Candy Drop</p>\r\n          <p className=\"sub-text\">NFT drop machine with fair mint</p>\r\n          {!walletAddress && renderNotConnectedContainer()}\r\n          {walletAddress && <CandyMachine walletAddress={window.solana} />}\r\n        </div>\r\n        <div className=\"footer-container\">\r\n          <img alt=\"Twitter Logo\" className=\"twitter-logo\" src={twitterLogo} />\r\n          <a\r\n            className=\"footer-text\"\r\n            href={TWITTER_LINK}\r\n            target=\"_blank\"\r\n            rel=\"noreferrer\"\r\n          >{`built on @${TWITTER_HANDLE}`}</a>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n","import { web3 } from '@project-serum/anchor';\r\n\r\n// CLI Properties Given to us\r\nconst candyMachineProgram = new web3.PublicKey(\r\n  'cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ'\r\n);\r\n\r\nconst TOKEN_METADATA_PROGRAM_ID = new web3.PublicKey(\r\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'\r\n);\r\n\r\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new web3.PublicKey(\r\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'\r\n);\r\nexport {\r\n  candyMachineProgram,\r\n  TOKEN_METADATA_PROGRAM_ID,\r\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\r\n};\r\n"],"sourceRoot":""}